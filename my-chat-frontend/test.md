"以下是几种计算斐波那契数列的 Python 代码实现：\n\n### 1. 递归实现（简单但效率低）\n```python\ndef fibonacci_recursive(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)\n\n# 示例：打印前10个斐波那契数\nfor i in range(10):\n    print(fibonacci_recursive(i))\n```\n\n### 2. 迭代实现（高效）\n```python\ndef fibonacci_iterative(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\n# 示例：打印前10个斐波那契数\nfor i in range(10):\n    print(fibonacci_iterative(i))\n```\n\n### 3. 带缓存的递归（记忆化优化）\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci_memoized(n):\n    if n <= 1:\n        return n\n    return fibonacci_memoized(n-1) + fibonacci_memoized(n-2)\n\n# 示例：打印前10个斐波那契数\nfor i in range(10):\n    print(fibonacci_memoized(i))\n```\n\n### 4. 生成器实现（按需生成）\n```python\ndef fibonacci_generator():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\n# 示例：打印前10个斐波那契数\nfib = fibonacci_generator()\nfor _ in range(10):\n print(next(fib))\n```\n\n### 时间复杂度分析：\n- 递归：O(2^n) （指数级）\n- 迭代：O(n) （线性）\n- 记忆化递归：O(n)\n- 生成器：O(n) （每次生成）\n\n对于大数计算（如 n>30），请避免使用纯递归方法，推荐使用迭代或记忆化版本。[DONE]"